<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>EpsilonZ&#39;s Blog</title>
  
  <subtitle>Compile the world, save the world.</subtitle>
  <link href="https://epsilonzyj.github.io/atom.xml" rel="self"/>
  
  <link href="https://epsilonzyj.github.io/"/>
  <updated>2025-07-27T15:11:59.218Z</updated>
  <id>https://epsilonzyj.github.io/</id>
  
  <author>
    <name>EpsilonZ</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CS224W | Machine Learning with Graphs</title>
    <link href="https://epsilonzyj.github.io/posts/c6b8d3b6.html"/>
    <id>https://epsilonzyj.github.io/posts/c6b8d3b6.html</id>
    <published>2025-07-27T15:11:59.218Z</published>
    <updated>2025-07-27T15:11:59.218Z</updated>
    
    <content type="html"><![CDATA[<h2 id="传统基于特征的方法｜Traditional-Feature-base-Methods"><a href="#传统基于特征的方法｜Traditional-Feature-base-Methods" class="headerlink" title="传统基于特征的方法｜Traditional Feature-base Methods"></a>传统基于特征的方法｜Traditional Feature-base Methods</h2><h3 id="节点中心性｜Node-Centrality"><a href="#节点中心性｜Node-Centrality" class="headerlink" title="节点中心性｜Node Centrality"></a>节点中心性｜Node Centrality</h3><h4 id="特征向量中心度｜Eigenvector-centrality"><a href="#特征向量中心度｜Eigenvector-centrality" class="headerlink" title="特征向量中心度｜Eigenvector centrality"></a>特征向量中心度｜Eigenvector centrality</h4><p>衡量节点重要性的一种中心性指标，不仅考虑节点的直接连接数量，还考虑其相邻节点的重要性。特征向量中心性通过计算图的邻接矩阵的主导特征向量（最大特征值对应的特征向量）来确定，每个节点的中心性得分与其邻居的得分成正比。这种方法可用于识别网络中影响力较大的节点，如社交网络中的关键人物或传播网络中的核心节点。</p><p>思想：对于节点v，如果v被重要的邻居节点$u\in N(v)$包围，那么这个节点就相对重要</p><script type="math/tex; mode=display">c_v = \frac{1}{\lambda} \sum_{u \in N(v)}c_u \longleftrightarrow \lambda \mathbf{c} = \mathbf{Ac}</script><p>其中：</p><ul><li>$\lambda$是某个正常量</li><li>A是邻接矩阵，且若$u\in N(v), A_{uv} = 1$</li><li>c为中心性向量(Centrality vector)</li></ul><p>最大的特征值$\lambda_{max}$总是正数且唯一</p><p>主导特征向量 $C_max$用于衡量图的中心性。</p><h4 id="中介中心性｜Betweenness-Centrality"><a href="#中介中心性｜Betweenness-Centrality" class="headerlink" title="中介中心性｜Betweenness Centrality"></a>中介中心性｜Betweenness Centrality</h4><p>衡量一个节点在图中充当其他节点之间“桥梁”作用的程度。具体而言，它表示该节点出现在所有最短路径中的频率，数值越高，说明该节点在信息传递或网络流动中的重要性越大。</p><p>思想：如果许多的最短路径都经过这个节点，那么这个节点就相对重要</p><p>公式具体如下：</p><script type="math/tex; mode=display">c_v = \sum_{s\neq v \neq t}\frac{在s和t之间包含节点v的最短路径数}{在s和t中的最短路径数}</script><h4 id="接近中心性｜Closeness-Centrality"><a href="#接近中心性｜Closeness-Centrality" class="headerlink" title="接近中心性｜Closeness Centrality"></a>接近中心性｜Closeness Centrality</h4><p>衡量一个节点与图中所有其他节点的平均最短路径距离的倒数。数值越高，表示该节点更容易接触到图中的其他节点，信息传播效率更高，通常用于评估节点在网络中的传播能力。</p><p>思想：如果一个节点到所有的节点的距离最小，那么这个节点相对重要</p><p>公式如下：</p><script type="math/tex; mode=display">c_v = \frac{1}{\sum_{u\neq v}u和v之间最短路径的长度}</script><h4 id="聚类系数｜Clustering-Coefficient"><a href="#聚类系数｜Clustering-Coefficient" class="headerlink" title="聚类系数｜Clustering Coefficient"></a>聚类系数｜Clustering Coefficient</h4><p>针对单个节点，定义为该节点的邻居之间实际存在的边数与可能存在的最大边数之比</p><p>公式：</p><script type="math/tex; mode=display">e_v = \frac{v节点的邻居节点之间的边数}{C_{k_v}^{2}}</script><p>其中，分母表示节点v的邻居节点两两相连得到的边数。</p><h4 id="图元频率向量｜Graphlet-Degree-Vector"><a href="#图元频率向量｜Graphlet-Degree-Vector" class="headerlink" title="图元频率向量｜Graphlet Degree Vector"></a>图元频率向量｜Graphlet Degree Vector</h4><h5 id="图元"><a href="#图元" class="headerlink" title="图元"></a>图元</h5><p>图元（Graphlets）：指小规模的、无方向或有方向的连通子图，通常用于分析复杂网络的局部结构。图元可以帮助识别网络的模式、节点的结构角色，并用于特征提取、网络比较和生物网络分析。</p><ul><li>度数计算的是节点接触多少条边</li><li>聚类系数计算的是节点接触多少个三角形</li><li>GDV计算的是节点接触多少个图元</li></ul><h5 id="图元度向量的作用"><a href="#图元度向量的作用" class="headerlink" title="图元度向量的作用"></a>图元度向量的作用</h5><p>考虑由2到5个节点组成的图元时：</p><ul><li>通过分析2到5个节点的所有可能连通子图，构建一个包含73维度的向量，该向量被视为节点的特征签名，用于描述其局部拓扑结构。</li><li>该向量不仅考虑节点的直接邻居，还能捕捉其在最多4跳范围内的互连关系</li><li>图元度向量提供了比单纯的节点度（Degree）或聚类系数（Clustering Coefficient）更丰富的结构信息</li></ul><h3 id="链接级预测任务｜Link-Level-Prediction-Task"><a href="#链接级预测任务｜Link-Level-Prediction-Task" class="headerlink" title="链接级预测任务｜Link-Level Prediction Task"></a>链接级预测任务｜Link-Level Prediction Task</h3><p>在此任务中，是基于现有的链接预测新的链接。在测试阶段，对所有的未连接节点对进行排序，并且预测最高的K个节点对。<strong>关键是设计一对节点的特征</strong>。</p><p>两种链接预测的形式：</p><ul><li>随机链接缺失边：随机移除一些链接，并且尝试去预测它们</li><li>随时间进行链接：<ul><li>对于给定的图$G[t_0,t_0’]$，图的边在时间$t_0’$之前，需要产生一个对在原图中不存在的链接的排序的表，其中这些链接是被预测在$G[t_1,t_1’]$中出现</li><li>评估：<ul><li>$n=|E_{new}|$：在测试阶段$[t_1,t_1’]$新出现的边</li><li>取出L中前n个元素并且计算正确的边数</li></ul></li></ul></li></ul><h4 id="通过相似性的链接预测"><a href="#通过相似性的链接预测" class="headerlink" title="通过相似性的链接预测"></a>通过相似性的链接预测</h4><p>方法：</p><ol><li>对于每一对节点$(x,y)$，计算相似性分数$c(x,y)$<ul><li>例如，可以计算相同的邻居数目</li></ul></li><li>按照相似性分数降序排列节点对</li><li>预测分数最高的n对作为新的链接</li><li>查看这些链接中哪些真实存在于图$G[t_1,t_1’]$中</li></ol><h4 id="基于距离的特征｜Distance-Based-Features"><a href="#基于距离的特征｜Distance-Based-Features" class="headerlink" title="基于距离的特征｜Distance-Based Features"></a>基于距离的特征｜Distance-Based Features</h4><p>使用两个节点之间最短路径的长度</p><p>缺陷：不能捕获领域重叠的信息</p><h4 id="局部邻域重叠｜Local-Neighborhood-Overlap"><a href="#局部邻域重叠｜Local-Neighborhood-Overlap" class="headerlink" title="局部邻域重叠｜Local Neighborhood Overlap"></a>局部邻域重叠｜Local Neighborhood Overlap</h4><p>捕获两个节点$v_1,v_2$之间共享的邻居节点</p><ul><li>Common neighbors: $|N(v_1)\cap N(v_2)|$</li><li>Jaccard’s coefficient: $\frac{|N(v_1)\cap N(v_2)|}{|N(v_1)\cup N(v_2)|}$</li><li>Adamic-Adar index: $\sum_{u\in N(v_1)\cap N(v_2)}\frac{1}{log(k_u)}, k_u: degrees\quad of\quad node\quad u$</li></ul><p>缺陷：当两个节点没有任何公共邻居时总为0，但是这两个节点在未来仍有可能被链接</p><h4 id="全局邻域重叠｜Global-Neighborhood-Overlap"><a href="#全局邻域重叠｜Global-Neighborhood-Overlap" class="headerlink" title="全局邻域重叠｜Global Neighborhood Overlap"></a>全局邻域重叠｜Global Neighborhood Overlap</h4><p>Katz index：计算一个给定的节点对中所有长度的路径的数目</p><p>方法：<strong>使用邻接矩阵的幂可以计算各种长度的路径数</strong></p><ul><li>$A_{uv}$表示节点u和v之间长度为1的路径</li><li>$A_{uv}^{l}$表示节点u和v之间长度为l的路径</li></ul><p>对于$v_1,v_2$的Katz index计算如下：</p><script type="math/tex; mode=display">S_{v_1v_2} = \sum_{l=1}^{\infty}\beta^{l}A_{v_1v_2}^{l}, 0<\beta<1:discount\quad factor</script><p>Katz index矩阵闭式计算：</p><script type="math/tex; mode=display">\mathbf{S} = \sum_{i=1}^{\infty}\beta^i\mathbf{A}^i = (\mathbf{I} - \beta\mathbf{A})^{-1}-\mathbf{I}</script><h3 id="图级别的特征｜Graph-Level-Features"><a href="#图级别的特征｜Graph-Level-Features" class="headerlink" title="图级别的特征｜Graph-Level Features"></a>图级别的特征｜Graph-Level Features</h3><h4 id="背景：核方法｜Kernel-Methods"><a href="#背景：核方法｜Kernel-Methods" class="headerlink" title="背景：核方法｜Kernel Methods"></a>背景：核方法｜Kernel Methods</h4><p>核方法被广泛应用于传统机器学习中的图级别预测任务。</p><p>核心思想: 设计核函数而非特征向量</p><ul><li>核函数$K(G, G’)\in R$衡量数据之间的相似性</li><li>核矩阵$K=(K(G, G’))_{G,G’}$必须始终保持半正定(即具有非负特征值)</li><li>存在特征表示$\Phi(·)$使得$K(G,G’)=\Phi(G)^T\Phi(G’)$</li><li>一旦定义好核函数，就可以直接使用现成的机器学习模型(如核支持向量机)进行预测</li></ul><h4 id="图核｜Graph-Kernels"><a href="#图核｜Graph-Kernels" class="headerlink" title="图核｜Graph Kernels"></a>图核｜Graph Kernels</h4><p>核心思想是设计核函数来衡量图之间的相似性，而不是直接使用特征向量。图核方法允许在不显式构造高维特征向量的情况下，利用核函数将图映射到一个高维特征空间，并应用标准的机器学习模型（如支持向量机 SVM）进行预测。</p><ul><li><a href="#图元核graphlet-kernel">Graphlet Kernel</a></li><li><a href="#weisfeiler-lehman-kernel">Weisfeiler-Lehman Kernel</a></li><li>Random-walk kernel</li><li>Shortest-path graph kernel</li></ul><h4 id="词袋｜Bag-of-Words"><a href="#词袋｜Bag-of-Words" class="headerlink" title="词袋｜Bag-of-Words"></a>词袋｜Bag-of-Words</h4><p>为图设计特征向量$\phi (G)$，一种方法就是设计词袋（Bag-of-Words，BoW）。</p><p>词袋（BoW）：对于文本，直接对出现的单词进行计数并作为其特征，其中并没有考虑顺序的因素。</p><p>对于拓展到图上的朴素的思想就是将节点视作单词。</p><p>e.g.对于向量[1, 4, 0]，可以表示为度为1，2，3的节点分别有1，4，0个。</p><h4 id="图元核｜Graphlet-Kernel"><a href="#图元核｜Graphlet-Kernel" class="headerlink" title="图元核｜Graphlet Kernel"></a>图元核｜Graphlet Kernel</h4><p>核心思想：计算在图中的不同图元的数目，将得到的特征向量记为$\mathbf{f}_G$</p><p>对给定的图$G$，以及一个图元表</p><script type="math/tex; mode=display">G_{k}=(g_{1}, g_{2},...,g_{n_k})</script><p>我们将图元计数得到的向量$\mathbf{f}_{G}\in R^{n_k}$定义为</p><script type="math/tex; mode=display">(\mathbf{f}_G)_i = (g_i \subseteq G),i = 1,2,...,n_k</script><p>对于给定的两个图G,G’，图元核可以通过以下的方式进行计算：</p><script type="math/tex; mode=display">K(G,G') = \mathbf{f}_{G}^{T}\mathbf{f}_{G'}</script><p><strong>问题：</strong>如果G和G’拥有不同的大小，那么值将会有偏移</p><p><strong>解决方法：</strong>将每个特征向量进行归一化</p><script type="math/tex; mode=display">\mathbf{h}_{G} = \frac{\mathbf{f}_{G}}{Sum(\mathbf{f}_{G})}</script><script type="math/tex; mode=display">K(G, G') = \mathbf{h}_{G}^{T}\mathbf{h}_{G'}</script><p><strong>缺陷：</strong>计算图元开销很大。对于计算一个大小为n的图中大小为k的图元，使用枚举法需要$n^k$次。计算某图是否是另一个图的子图是NP难问题。但对于节点度数上限为$d$的图，计算大小为k的图元数目，现在存在一个$O(nd^{k-1})$的算法。</p><h4 id="Weisfeiler-Lehman-Kernel"><a href="#Weisfeiler-Lehman-Kernel" class="headerlink" title="Weisfeiler-Lehman Kernel"></a>Weisfeiler-Lehman Kernel</h4><p>思想：使用领域的结构来丰富节点的表示。</p><p>从Bag of node degrees提取出的信息是1-邻域的信息，使用算法Color refinement可以提取多领域信息。</p><h5 id="颜色细化｜Color-Refinement"><a href="#颜色细化｜Color-Refinement" class="headerlink" title="颜色细化｜Color Refinement"></a>颜色细化｜Color Refinement</h5><p>输入：图G和节点集合V</p><ul><li>对于每个节点v，给定一个初试颜色$c^{(0)}(v)$</li><li>通过以下公式迭代更新节点颜色，其中HASH将不同的输入映射到不同颜色：</li></ul><script type="math/tex; mode=display">c^{(k+1)}(v) = HASH(\{c^{(k)}(v),\{c^{(k)}(u)\}_{u\in N(v)}\})</script><ul><li>通过K步颜色更新，$c^{K}(v)$将提取出K邻域的结构信息</li></ul><h5 id="WL-Kernel的优势"><a href="#WL-Kernel的优势" class="headerlink" title="WL Kernel的优势"></a>WL Kernel的优势</h5><p>WL kernel计算效率很高，因为每次更新的时间复杂度都是线性的。而计算核值的时候，只有同时出现在两个图中的颜色才会被追踪。因此，颜色数目最多不会超过节点数目。计算颜色的数目的时间复杂度为线性的。因此，总的时间复杂度为线性的。</p><h2 id="节点嵌入｜Node-Embedding"><a href="#节点嵌入｜Node-Embedding" class="headerlink" title="节点嵌入｜Node Embedding"></a>节点嵌入｜Node Embedding</h2><p>假设目前拥有一个图$G$，其中</p><ul><li>$V$是节点集</li><li>$A$是邻接矩阵（假设为0-1邻接矩阵）</li><li>为了简便起见，假设没有节点信息和额外信息</li><li>假设是无向图</li></ul><p>目标：在原始网络中的相似性<script type="math/tex">similarity(u, v)\approx\mathbf{z_{v}^{T}z_{u}}</script></p><p>节点嵌入学习：</p><ol><li>编码器将节点映射为嵌入</li><li>定义节点相似性函数（例如用于衡量原始网络中的相似性）</li><li>解码器DEC将嵌入映射为相似性分数</li><li>优化编码器的参数使得<script type="math/tex">similarity(u, v)\approx\mathbf{z_{v}^{T}z_{u}}</script></li></ol><h3 id="编码器｜Encoder"><a href="#编码器｜Encoder" class="headerlink" title="编码器｜Encoder"></a>编码器｜Encoder</h3><p>将每个节点映射到一个低维向量</p><script type="math/tex; mode=display">ENC(v) = \mathbf{z}_v</script><h4 id="最简单的编码"><a href="#最简单的编码" class="headerlink" title="最简单的编码"></a>最简单的编码</h4><p>最简单的编码方法：编码仅为一个嵌入的查找</p><script type="math/tex; mode=display">ENC(v) = \mathbf{z}_{v} = \mathbf{Z}\cdot v</script><script type="math/tex; mode=display">\mathbf{Z}\in R^{d\times |V|}：矩阵，每一列是一个节点嵌入（我们需要学习/优化的目标）</script><script type="math/tex; mode=display">v\in \mathrm{II}^{|V|}：指示向量，在一列中只有0和1，用于指示节点v</script><p>缺陷：参数过多，矩阵大小与节点数成正比。节点数较多的情况下运算很慢。</p><h3 id="相似性函数｜Similarity-function"><a href="#相似性函数｜Similarity-function" class="headerlink" title="相似性函数｜Similarity function"></a>相似性函数｜Similarity function</h3><p>指定在向量空间中的关系如何映射到原始网络中的关系</p><script type="math/tex; mode=display">similarity(u,v)\approx\mathbf{z}_{v}^{T}\mathbf{z}_{u}</script><h3 id="随机游走嵌入｜Random-Walk-Embedding"><a href="#随机游走嵌入｜Random-Walk-Embedding" class="headerlink" title="随机游走嵌入｜Random-Walk Embedding"></a>随机游走嵌入｜Random-Walk Embedding</h3><ol><li>估计使用随机游走策略的决策$R$，从节点$u$出发访问节点$v$的概率</li><li>优化嵌入方式来编码这些随机游走的概率</li></ol><p>优化的特征学习：</p><ul><li>给定图$G=(V,E)$</li><li>目标是学习一个映射$f:u\rightarrow R^{d}: f(u) = z_{u}$</li><li>对数相似性目标：<script type="math/tex; mode=display"> max_{f}\sum_{u\in V}logP(N_{R}(u)|\mathbf{z}_{u}),N_{R}(u)是使用策略R的节点u的一个邻居</script></li></ul><p>对于给定的节点u，我们想要学习在随机游走的邻域$N_{R}(u)$中可预测的节点的特征表示。</p><h4 id="随机游走优化算法"><a href="#随机游走优化算法" class="headerlink" title="随机游走优化算法"></a>随机游走优化算法</h4><ol><li>从每个节点u开始在图中使用随机游走策略R走固定长度的短路径</li><li>对于每个节点u得到可重集合$N_{R}(u)$（记录使用从u开始的随机游走策略访问的节点）</li><li>根据给定节点$u$预测邻域$N_{R}(u)$来优化嵌入</li></ol><p>等价的，优化目标变为</p><script type="math/tex; mode=display">L = \sum_{u\in V}\sum_{v\in N_{R}(u)}-log(P(v|\mathbf{z}_u))</script><p>目标：优化嵌入$z_u$以最大化随机游走的可能性</p><p>使用softmax参数化$P(v|\mathbf{z}_u)$:</p><script type="math/tex; mode=display">P(v|\mathbf{z}_u) = \frac{exp(\mathbf{z}_{u}^{T}\mathbf{z}_{v})}{\sum_{n\in V}exp(\mathbf{z}_{u}^{T}\mathbf{z}_{n})}</script><p>因此，最终的优化的目标为（时间复杂度为$O(|V|^{2})）$：</p><script type="math/tex; mode=display">L = \sum_{u\in V}\sum_{v\in N_{R}(u)}-log(\frac{exp(\mathbf{z}_{u}^{T}\mathbf{z}_{v})}{\sum_{n\in V}exp(\mathbf{z}_{u}^{T}\mathbf{z}_{n})})</script><h4 id="负采样｜Negative-Sampling"><a href="#负采样｜Negative-Sampling" class="headerlink" title="负采样｜Negative Sampling"></a>负采样｜Negative Sampling</h4><p>由于原来需要优化的目标时间复杂度过高，需要对目标进近似，此处采用负采样的方法：</p><script type="math/tex; mode=display">log(\frac{exp(\mathbf{z}_{u}^{T}\mathbf{z}_{v})}{\sum_{n\in V}exp(\mathbf{z}_{u}^{T}\mathbf{z}_{n})}) \\approx log(\sigma(\mathbf{z}_{u}^{T}\mathbf{z}_{v})) - \sum_{i=1}^{k}log(\sigma(\mathbf{z}_{u}^{T}\mathbf{z_{n_{i}}})),n_{i}\sim P_{V}</script><p>在此过程中，对于每个探测随机采样k个负节点</p><p>其中更大的k给出的估计越具有鲁棒性，同时也会在负样例中给出更高的偏移。</p><p>实际中k取5到20。</p><p>优化方法使用<strong>随机梯度下降法</strong>。</p><hr><h2 id="参考文献｜References"><a href="#参考文献｜References" class="headerlink" title="参考文献｜References"></a>参考文献｜References</h2><ol><li>CS224W-Video:<a href="https://www.bilibili.com/video/BV1RZ4y1c7Co">CN</a>,<a href="https://www.youtube.com/watch?v=JAB_plj2rbA">EN</a></li></ol>]]></content>
    
    
    <summary type="html">本文基于Stanford的CS224W中一些理论内容，介绍有关图机器学习的手段与方法</summary>
    
    
    
    <category term="AI" scheme="https://epsilonzyj.github.io/categories/AI/"/>
    
    <category term="Graph ML" scheme="https://epsilonzyj.github.io/categories/AI/Graph-ML/"/>
    
    
    <category term="AI" scheme="https://epsilonzyj.github.io/tags/AI/"/>
    
    <category term="Graph ML" scheme="https://epsilonzyj.github.io/tags/Graph-ML/"/>
    
  </entry>
  
  <entry>
    <title>ICS实验随笔</title>
    <link href="https://epsilonzyj.github.io/posts/67ad26dd.html"/>
    <id>https://epsilonzyj.github.io/posts/67ad26dd.html</id>
    <published>2025-03-14T16:49:57.000Z</published>
    <updated>2025-07-27T15:11:59.218Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于右移的问题"><a href="#关于右移的问题" class="headerlink" title="关于右移的问题"></a>关于右移的问题</h2><h3 id="问题发现"><a href="#问题发现" class="headerlink" title="问题发现"></a>问题发现</h3><p>在上机进行ICS实验中，有一个函数要求产生highbit到lowbit全为1的数字。一个相当简单的想法是直接将0xFFFFFFFF右移hinghbit+1位后再 移回来，再取反，便可以得到第0位到第highbit位的数字，然后再进行后续操作。</p><p>然而在这个问题中，遇到了一些问题，在此记录一下。</p><h4 id="左右移的位数为负数"><a href="#左右移的位数为负数" class="headerlink" title="左右移的位数为负数"></a>左右移的位数为负数</h4><p><strong>负数移位</strong>（如x &gt;&gt; -1）属于<strong>未定义行为</strong>，不同平台和编译器会产生不同结果，部分会在编译阶段报错，而在一些特定运算下，如x &gt;&gt; (m-n)中，可能会因为某些特殊赋值而出现负数，应当进行避免。</p><h4 id="右移溢出"><a href="#右移溢出" class="headerlink" title="右移溢出"></a>右移溢出</h4><p>根据上面函数所需要求，一开始写出如下的函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">bitMask</span><span class="params">(<span class="type">int</span> highbit, <span class="type">int</span> lowbit)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> high = ~((<span class="number">0xFFFFFFFF</span> &gt;&gt; (highbit + <span class="number">1</span>)) &lt;&lt; (highbit + <span class="number">1</span>));</span><br><span class="line">    <span class="type">int</span> low  = ((~<span class="number">0</span>) &lt;&lt; lowbit);</span><br><span class="line">    <span class="keyword">return</span> high &amp; low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而，在测试调试时发现，当highbit==31时，函数值则会有问题。溯源后发现，highbit+1==32时，high的值一直为0xFFFFFFFF，并不符合预期的0x0。起初以为是自己逻辑有问题，于是进行了一下测试，首先把highbit+1替换为32：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">bitMask</span><span class="params">(<span class="type">int</span> highbit, <span class="type">int</span> lowbit)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> high = ~((<span class="number">0xFFFFFFFF</span> &gt;&gt; <span class="number">32</span>) &lt;&lt; <span class="number">32</span>);</span><br><span class="line">    <span class="type">int</span> low  = ((~<span class="number">0</span>) &lt;&lt; lowbit);</span><br><span class="line">    <span class="keyword">return</span> high &amp; low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而出乎意料的是，此时high的值变为正常的0x0，此时也开始报了warning，但显然不看warning是一个好习惯（经典笑话，笑）。则考虑到32与highbit+1的差异性，一开始没考虑常量和变量的问题，以为是32是unsigned类型而另一个是int类型，由于数据类型的问题可能会存在一些区别，虽然感觉这种思路似乎很离谱，且并没有什么道理可言，但是还是测试了一下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">bitMask</span><span class="params">(<span class="type">int</span> highbit, <span class="type">int</span> lowbit)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> high = ~((<span class="number">0xFFFFFFFF</span> &gt;&gt; (<span class="type">unsigned</span>)(highbit + <span class="number">1</span>)) &lt;&lt; (<span class="type">unsigned</span>)(highbit + <span class="number">1</span>));</span><br><span class="line">    <span class="type">int</span> low  = ((~<span class="number">0</span>) &lt;&lt; lowbit);</span><br><span class="line">    <span class="keyword">return</span> high &amp; low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候high又变成了0xFFFFFFFF，这有些出乎意料，一时就没什么头绪，不知道有什么问题，于是就开始怀疑编译器是否有编译优化的问题了。</p><h5 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h5><p>经过查找资料，发现右移时右侧操作数大于或等于左侧操作数的位数是属于未定义运算，而编译时确实存在一些编译优化。对于未定义行为，在编译时，分别发生了以下两件事：</p><ul><li>常量表达式：编译器在编译阶段进行常量求值，依据标准未定义的情况下可能直接优化成 0。</li><li>变量表达式：运行时生成的移位指令通常只取移位数的低 5 位（对于 32 位整数而言），因而 32 的低 5 位为 0，实际移位相当于“右移 0 位”，结果保持原值 0xFFFFFFFF。</li></ul><p>当表达式写为 0xFFFFFFFF &gt;&gt; (highbit+1) 时，虽然 (highbit+1) 计算结果为 32，但由于其为运行时求值的变量表达式，编译器生成的汇编指令遵循硬件实际移位机制。</p><p>在许多 CPU 架构（例如 x86）中，用于右移操作的指令（如 SHR 指令）通常只取移位数的低 5 位（对于 32 位操作数），即实际移位数 = 给定移位数 mod 32。</p><p>当 (highbit+1) 等于 32 时，其低 5 位为 0，故实际移位操作相当于“右移 0 位”，因此结果仍为原值 0xFFFFFFFF。</p><p>这种处理方式与硬件实现有关，虽然在 C 语言标准中两种写法的行为都是未定义的，但实际运行时硬件指令的“模 32”特性使得结果不同。</p><p>因此，对于上述问题，一种解决办法就是分开写，即移两次位。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">bitMask</span><span class="params">(<span class="type">int</span> highbit, <span class="type">int</span> lowbit)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> high = ~((((<span class="number">0xFFFFFFFF</span> &gt;&gt; highbit) &gt;&gt; <span class="number">1</span>) &lt;&lt; highbit) &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> low  = ((~<span class="number">0</span>) &lt;&lt; lowbit);</span><br><span class="line">    <span class="keyword">return</span> high &amp; low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="寄存器保护"><a href="#寄存器保护" class="headerlink" title="寄存器保护"></a>寄存器保护</h2><h3 id="问题发现-1"><a href="#问题发现-1" class="headerlink" title="问题发现"></a>问题发现</h3><p>在某次实验中，根据实验要求，需要使用汇编语言编写其中的部分函数。当然这个实验主要的内容实在优化炫技（划掉），不过在实验中遇到了一个很奇怪的问题。</p><p><em>注意：实验环境为Visual Studio 2022，编译采用x86架，构。其中在生成依赖项时需要对项目进行设置，对项目名称右击后点击生成依赖项下的生成子定义，并勾选masm，这样可以实现汇编和C混合编程。其余均为默认设置。感兴趣的同学可以根据以上内容进行复现。</em></p><p>在实验中需要在Debug版本和Release版本下分别进行程序运行速度的比较，编译阶段并没有问题，Debug版本可以正常运行。但是在Release版本中，当运行即将退出主函数时，抛出了异常。（由于时间较久远，且笔者较懒，没有复现的图片，了解一下原理即可）</p><h3 id="问题解决-1"><a href="#问题解决-1" class="headerlink" title="问题解决"></a>问题解决</h3><p>根据反汇编调试，在return 0处打断点，在查看反汇编后，发现在退出主函数之前进行了一些安全检查，其中一项就是进行寄存器的检查。而在本次场景中，因为Release版本优化程度较高，在程序编译时默认不会使用到寄存器ebx，因而在程序退出时会检查ebx是否进行改动。很遗憾，笔者水平较差，在编写x86汇编的时候用到了ebx并且没有进行寄存器保护，因此由于篡改寄存器导致程序崩溃。</p><p>以下给出原始的代码（后期模拟出来的）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line">.686P</span><br><span class="line">.model flat, c</span><br><span class="line">printf proto c :ptr sbyte, :vararg</span><br><span class="line">; includelib  libcmt.lib</span><br><span class="line">includelib  legacy_stdio_definitions.lib </span><br><span class="line"></span><br><span class="line">student  struct</span><br><span class="line">    sname   db   8 dup(0)</span><br><span class="line">    sid     db   11 dup(0)</span><br><span class="line">    align   2    ; 指明对齐方式，汇编语言默认是紧凑存放</span><br><span class="line">                 ; 可以实验一下，去掉对齐方式伪指令的结果</span><br><span class="line">    scores  dw   8  dup(0)</span><br><span class="line">    average dw   0</span><br><span class="line">student   ends</span><br><span class="line"></span><br><span class="line">.data</span><br><span class="line">   lpfmt  db &quot;%s %s %d %d&quot;,0dh,0ah,0</span><br><span class="line">   lpfmt_string  db &quot;%s  &quot;,0</span><br><span class="line">   lpfmt_num  db &quot;%d  &quot;,0</span><br><span class="line">   lpfmt_size    db  &quot;size of struct %d  &quot;,0dh,0ah,0</span><br><span class="line">   lpfmt_offset  db  0dh,0ah,&quot;offset of scores %d  &quot;,0dh,0ah,0</span><br><span class="line"></span><br><span class="line">.code</span><br><span class="line">;  显示学生信息</span><br><span class="line">;  sptr 学生数组的首地址</span><br><span class="line">;  num  学生人数</span><br><span class="line">;  注意， printf 中会用到一些寄存器，也没有保护</span><br><span class="line">;         即执行 printf前后，一个寄存器中的内容发生变化</span><br><span class="line"></span><br><span class="line">computeAverageScoreAsmOpt proc sptr: dword, num: dword</span><br><span class="line">    local s: dword</span><br><span class="line"></span><br><span class="line">    mov edx, sptr</span><br><span class="line">    mov eax, 0</span><br><span class="line">    mov ecx, 0</span><br><span class="line"></span><br><span class="line">LOOPI:</span><br><span class="line">                    ;int sum = 0</span><br><span class="line">    mov eax, 0</span><br><span class="line">    mov s, eax</span><br><span class="line">                    ;s[i].scores[0]</span><br><span class="line">    mov ebx, 026h</span><br><span class="line">    imul ebx, ecx</span><br><span class="line">    add ebx, 014h</span><br><span class="line">    movzx eax, word ptr[edx+ebx]</span><br><span class="line">                    ;sum = sum + s[i].scores[j]</span><br><span class="line">    mov ebx, s</span><br><span class="line">    add ebx, eax</span><br><span class="line">    mov s, ebx</span><br><span class="line"></span><br><span class="line">                    ;s[i].scores[1]</span><br><span class="line">    mov ebx, 026h</span><br><span class="line">    imul ebx, ecx</span><br><span class="line">    add ebx, 016h</span><br><span class="line">    movzx eax, word ptr[edx+ebx]</span><br><span class="line">                    ;sum = sum + s[i].scores[j]</span><br><span class="line">    mov ebx, s</span><br><span class="line">    add ebx, eax</span><br><span class="line">    mov s, ebx</span><br><span class="line">                    </span><br><span class="line">                    ;s[i].scores[2]</span><br><span class="line">    mov ebx, 026h</span><br><span class="line">    imul ebx, ecx</span><br><span class="line">    add ebx, 018h</span><br><span class="line">    movzx eax, word ptr[edx+ebx]</span><br><span class="line">                    ;sum = sum + s[i].scores[j]</span><br><span class="line">    mov ebx, s</span><br><span class="line">    add ebx, eax</span><br><span class="line">    mov s, ebx </span><br><span class="line">    </span><br><span class="line">                    ;s[i].scores[3]</span><br><span class="line">    mov ebx, 026h</span><br><span class="line">    imul ebx, ecx</span><br><span class="line">    add ebx, 01Ah</span><br><span class="line">    movzx eax, word ptr[edx+ebx]</span><br><span class="line">                    ;sum = sum + s[i].scores[j]</span><br><span class="line">    mov ebx, s</span><br><span class="line">    add ebx, eax</span><br><span class="line">    mov s, ebx</span><br><span class="line"></span><br><span class="line">                    ;s[i].scores[4]</span><br><span class="line">    mov ebx, 026h</span><br><span class="line">    imul ebx, ecx</span><br><span class="line">    add ebx, 01Ch</span><br><span class="line">    movzx eax, word ptr[edx+ebx]</span><br><span class="line">                    ;sum = sum + s[i].scores[j]</span><br><span class="line">    mov ebx, s</span><br><span class="line">    add ebx, eax</span><br><span class="line">    mov s, ebx</span><br><span class="line"></span><br><span class="line">                    ;s[i].scores[5]</span><br><span class="line">    mov ebx, 026h</span><br><span class="line">    imul ebx, ecx</span><br><span class="line">    add ebx, 01Eh</span><br><span class="line">    movzx eax, word ptr[edx+ebx]</span><br><span class="line">                    ;sum = sum + s[i].scores[j]</span><br><span class="line">    mov ebx, s</span><br><span class="line">    add ebx, eax</span><br><span class="line">    mov s, ebx</span><br><span class="line">                    </span><br><span class="line">                    ;s[i].scores[6]</span><br><span class="line">    mov ebx, 026h</span><br><span class="line">    imul ebx, ecx</span><br><span class="line">    add ebx, 020h</span><br><span class="line">    movzx eax, word ptr[edx+ebx]</span><br><span class="line">                    ;sum = sum + s[i].scores[j]</span><br><span class="line">    mov ebx, s</span><br><span class="line">    add ebx, eax</span><br><span class="line">    mov s, ebx  </span><br><span class="line">    </span><br><span class="line">                    ;s[i].scores[7]</span><br><span class="line">    mov ebx, 026h</span><br><span class="line">    imul ebx, ecx</span><br><span class="line">    add ebx, 022h</span><br><span class="line">    movzx eax, word ptr[edx+ebx]</span><br><span class="line">                    ;sum = sum + s[i].scores[j]</span><br><span class="line">    mov ebx, s</span><br><span class="line">    add ebx, eax</span><br><span class="line">    mov s, ebx</span><br><span class="line">                    </span><br><span class="line">                    ;sum / 8</span><br><span class="line">    mov eax, s</span><br><span class="line">    sar eax, 3</span><br><span class="line">                    ;s[i].average = sum/8</span><br><span class="line">    mov ebx, 026h</span><br><span class="line">    imul ebx, ecx</span><br><span class="line">    mov word ptr[edx+ebx+024h], ax</span><br><span class="line">                    ;i ++</span><br><span class="line">    inc ecx</span><br><span class="line">                    ;i == num ?</span><br><span class="line">    cmp ecx,num</span><br><span class="line">    jne LOOPI</span><br><span class="line"></span><br><span class="line">    ret</span><br><span class="line">computeAverageScoreAsmOpt endp</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>寄存器保护其实是一个非常简单非常常见的想法，但是由于在编写函数时，笔者原想要减少指令以换取（似乎）更快的速度，同时也是懒得写（划掉，怎么能把最重要的原因写出来），因此并没有做任何寄存器保护的办法。</p><p>接下来就简单讲一下寄存器保护思路：</p><ul><li>对于eax等寄存器，直接压入栈中即可</li><li>对于ebp，将ebp压入栈中，同时将esp赋值给ebp（即让ebp指向原始栈顶，方便后续esp和ebp等在函数返回时/后恢复原来的值）</li><li>对于esp，esp减少一部分值，即指向更小的地址，建立一个新栈</li></ul><p>而在实验中，由于并没有（直接）使用ebp、esp等寄存器，因而就对这两个不做特殊的保护了，而将其余寄存器全部压入栈中，在函数结束时再弹出。由于懒（划掉），笔者将所有的可能用到的寄存器均压入了栈中，而不是将此函数中用到的寄存器压入栈中（反正结果对了就行了，划掉）。</p><p>以下是修改后的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line">.686P</span><br><span class="line">.model flat, c</span><br><span class="line">printf proto c :ptr sbyte, :vararg</span><br><span class="line">; includelib  libcmt.lib</span><br><span class="line">includelib  legacy_stdio_definitions.lib </span><br><span class="line"></span><br><span class="line">student  struct</span><br><span class="line">    sname   db   8 dup(0)</span><br><span class="line">    sid     db   11 dup(0)</span><br><span class="line">    align   2    ; 指明对齐方式，汇编语言默认是紧凑存放</span><br><span class="line">                 ; 可以实验一下，去掉对齐方式伪指令的结果</span><br><span class="line">    scores  dw   8  dup(0)</span><br><span class="line">    average dw   0</span><br><span class="line">student   ends</span><br><span class="line"></span><br><span class="line">.data</span><br><span class="line">   lpfmt  db &quot;%s %s %d %d&quot;,0dh,0ah,0</span><br><span class="line">   lpfmt_string  db &quot;%s  &quot;,0</span><br><span class="line">   lpfmt_num  db &quot;%d  &quot;,0</span><br><span class="line">   lpfmt_size    db  &quot;size of struct %d  &quot;,0dh,0ah,0</span><br><span class="line">   lpfmt_offset  db  0dh,0ah,&quot;offset of scores %d  &quot;,0dh,0ah,0</span><br><span class="line"></span><br><span class="line">.code</span><br><span class="line">;  显示学生信息</span><br><span class="line">;  sptr 学生数组的首地址</span><br><span class="line">;  num  学生人数</span><br><span class="line">;  注意， printf 中会用到一些寄存器，也没有保护</span><br><span class="line">;         即执行 printf前后，一个寄存器中的内容发生变化</span><br><span class="line"></span><br><span class="line">computeAverageScoreAsmOpt proc sptr: dword, num: dword</span><br><span class="line">    local s: dword</span><br><span class="line"></span><br><span class="line">    push eax</span><br><span class="line">    push ebx</span><br><span class="line">    push ecx</span><br><span class="line">    push edx</span><br><span class="line">    push esi</span><br><span class="line">    push edi</span><br><span class="line"></span><br><span class="line">    mov edx, sptr</span><br><span class="line">    mov eax, 0</span><br><span class="line">    mov ecx, 0</span><br><span class="line"></span><br><span class="line">LOOPI:</span><br><span class="line">                    ;int sum = 0</span><br><span class="line">    mov eax, 0</span><br><span class="line">    mov s, eax</span><br><span class="line">                    ;s[i].scores[0]</span><br><span class="line">    mov ebx, 026h</span><br><span class="line">    imul ebx, ecx</span><br><span class="line">    add ebx, 014h</span><br><span class="line">    movzx eax, word ptr[edx+ebx]</span><br><span class="line">                    ;sum = sum + s[i].scores[j]</span><br><span class="line">    mov ebx, s</span><br><span class="line">    add ebx, eax</span><br><span class="line">    mov s, ebx</span><br><span class="line"></span><br><span class="line">                    ;s[i].scores[1]</span><br><span class="line">    mov ebx, 026h</span><br><span class="line">    imul ebx, ecx</span><br><span class="line">    add ebx, 016h</span><br><span class="line">    movzx eax, word ptr[edx+ebx]</span><br><span class="line">                    ;sum = sum + s[i].scores[j]</span><br><span class="line">    mov ebx, s</span><br><span class="line">    add ebx, eax</span><br><span class="line">    mov s, ebx</span><br><span class="line">                    </span><br><span class="line">                    ;s[i].scores[2]</span><br><span class="line">    mov ebx, 026h</span><br><span class="line">    imul ebx, ecx</span><br><span class="line">    add ebx, 018h</span><br><span class="line">    movzx eax, word ptr[edx+ebx]</span><br><span class="line">                    ;sum = sum + s[i].scores[j]</span><br><span class="line">    mov ebx, s</span><br><span class="line">    add ebx, eax</span><br><span class="line">    mov s, ebx </span><br><span class="line">    </span><br><span class="line">                    ;s[i].scores[3]</span><br><span class="line">    mov ebx, 026h</span><br><span class="line">    imul ebx, ecx</span><br><span class="line">    add ebx, 01Ah</span><br><span class="line">    movzx eax, word ptr[edx+ebx]</span><br><span class="line">                    ;sum = sum + s[i].scores[j]</span><br><span class="line">    mov ebx, s</span><br><span class="line">    add ebx, eax</span><br><span class="line">    mov s, ebx</span><br><span class="line"></span><br><span class="line">                    ;s[i].scores[4]</span><br><span class="line">    mov ebx, 026h</span><br><span class="line">    imul ebx, ecx</span><br><span class="line">    add ebx, 01Ch</span><br><span class="line">    movzx eax, word ptr[edx+ebx]</span><br><span class="line">                    ;sum = sum + s[i].scores[j]</span><br><span class="line">    mov ebx, s</span><br><span class="line">    add ebx, eax</span><br><span class="line">    mov s, ebx</span><br><span class="line"></span><br><span class="line">                    ;s[i].scores[5]</span><br><span class="line">    mov ebx, 026h</span><br><span class="line">    imul ebx, ecx</span><br><span class="line">    add ebx, 01Eh</span><br><span class="line">    movzx eax, word ptr[edx+ebx]</span><br><span class="line">                    ;sum = sum + s[i].scores[j]</span><br><span class="line">    mov ebx, s</span><br><span class="line">    add ebx, eax</span><br><span class="line">    mov s, ebx</span><br><span class="line">                    </span><br><span class="line">                    ;s[i].scores[6]</span><br><span class="line">    mov ebx, 026h</span><br><span class="line">    imul ebx, ecx</span><br><span class="line">    add ebx, 020h</span><br><span class="line">    movzx eax, word ptr[edx+ebx]</span><br><span class="line">                    ;sum = sum + s[i].scores[j]</span><br><span class="line">    mov ebx, s</span><br><span class="line">    add ebx, eax</span><br><span class="line">    mov s, ebx  </span><br><span class="line">    </span><br><span class="line">                    ;s[i].scores[7]</span><br><span class="line">    mov ebx, 026h</span><br><span class="line">    imul ebx, ecx</span><br><span class="line">    add ebx, 022h</span><br><span class="line">    movzx eax, word ptr[edx+ebx]</span><br><span class="line">                    ;sum = sum + s[i].scores[j]</span><br><span class="line">    mov ebx, s</span><br><span class="line">    add ebx, eax</span><br><span class="line">    mov s, ebx</span><br><span class="line">                    </span><br><span class="line">                    ;sum / 8</span><br><span class="line">    mov eax, s</span><br><span class="line">    sar eax, 3</span><br><span class="line">                    ;s[i].average = sum/8</span><br><span class="line">    mov ebx, 026h</span><br><span class="line">    imul ebx, ecx</span><br><span class="line">    mov word ptr[edx+ebx+024h], ax</span><br><span class="line">                    ;i ++</span><br><span class="line">    inc ecx</span><br><span class="line">                    ;i == num ?</span><br><span class="line">    cmp ecx,num</span><br><span class="line">    jne LOOPI</span><br><span class="line"></span><br><span class="line">    pop edi</span><br><span class="line">    pop esi</span><br><span class="line">    pop edx</span><br><span class="line">    pop ecx</span><br><span class="line">    pop ebx</span><br><span class="line">    pop eax</span><br><span class="line"></span><br><span class="line">    ret</span><br><span class="line">computeAverageScoreAsmOpt endp</span><br><span class="line">end</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">ICS课程中所踩的坑及编程中可能有的问题</summary>
    
    
    
    <category term="Course" scheme="https://epsilonzyj.github.io/categories/Course/"/>
    
    <category term="ICS" scheme="https://epsilonzyj.github.io/categories/Course/ICS/"/>
    
    
    <category term="HUST" scheme="https://epsilonzyj.github.io/tags/HUST/"/>
    
    <category term="ICS" scheme="https://epsilonzyj.github.io/tags/ICS/"/>
    
    <category term="C/C++" scheme="https://epsilonzyj.github.io/tags/C-C/"/>
    
    <category term="Assembly" scheme="https://epsilonzyj.github.io/tags/Assembly/"/>
    
  </entry>
  
  <entry>
    <title>HUST仓库</title>
    <link href="https://epsilonzyj.github.io/posts/c723aac6.html"/>
    <id>https://epsilonzyj.github.io/posts/c723aac6.html</id>
    <published>2025-03-03T14:13:31.000Z</published>
    <updated>2025-07-27T15:11:59.218Z</updated>
    
    <content type="html"><![CDATA[<p>本博客用于记录作者本科时期的课程实验或课程设计。</p><ol><li><a href="https://github.com/EpsilonZYJ/DataStructureExp">数据结构实验</a></li><li><a href="https://github.com/EpsilonZYJ/Sudoku">基于SAT问题的数独求解（程序综合课程设计）</a></li><li><a href="https://github.com/EpsilonZYJ/AlgorithmExperiment">算法设计实验</a></li><li><a href="https://github.com/EpsilonZYJ/CppExperiement">C++实验</a></li><li><a href="https://github.com/EpsilonZYJ/Digital-Circuit-Experiment">数字电路与逻辑设计实验</a></li><li><a href="https://github.com/EpsilonZYJ/IntroductionToAI">人工智能导论课程作业</a></li></ol>]]></content>
    
    
    <summary type="html">HUST实验和课程设计demo</summary>
    
    
    
    <category term="HUST" scheme="https://epsilonzyj.github.io/categories/HUST/"/>
    
    
    <category term="HUST" scheme="https://epsilonzyj.github.io/tags/HUST/"/>
    
  </entry>
  
  <entry>
    <title>GNN经典模型 | GNN Basic Models</title>
    <link href="https://epsilonzyj.github.io/posts/4a93988c.html"/>
    <id>https://epsilonzyj.github.io/posts/4a93988c.html</id>
    <published>2025-03-02T11:36:18.000Z</published>
    <updated>2025-07-27T15:11:59.218Z</updated>
    
    
    
    
    <category term="AI" scheme="https://epsilonzyj.github.io/categories/AI/"/>
    
    <category term="Graph ML" scheme="https://epsilonzyj.github.io/categories/AI/Graph-ML/"/>
    
    <category term="GNN" scheme="https://epsilonzyj.github.io/categories/AI/Graph-ML/GNN/"/>
    
    
    <category term="AI" scheme="https://epsilonzyj.github.io/tags/AI/"/>
    
    <category term="Graph ML" scheme="https://epsilonzyj.github.io/tags/Graph-ML/"/>
    
    <category term="GNN" scheme="https://epsilonzyj.github.io/tags/GNN/"/>
    
    <category term="GNN With Attention" scheme="https://epsilonzyj.github.io/tags/GNN-With-Attention/"/>
    
  </entry>
  
  <entry>
    <title>图神经网络简介 | An Introduction to GNN</title>
    <link href="https://epsilonzyj.github.io/posts/63fed347.html"/>
    <id>https://epsilonzyj.github.io/posts/63fed347.html</id>
    <published>2025-02-27T13:49:55.000Z</published>
    <updated>2025-07-27T15:11:59.218Z</updated>
    
    <content type="html"><![CDATA[<h2 id="图的表示"><a href="#图的表示" class="headerlink" title="图的表示"></a>图的表示</h2><p>对于图，有</p><ul><li>V：Vertex(or node) attributes</li><li>E：Edge(or link) attributes and directions</li><li>U：Global(or master node) attributes</li></ul><p>分别可以使用向量embedding来进行表示。</p><h3 id="图片转化为图"><a href="#图片转化为图" class="headerlink" title="图片转化为图"></a>图片转化为图</h3><p>将第$(i, j)$位置的像素映射为第$(i, j)$位置的节点（可以将节点按照类似像素排序的规则排序，即每行每列个数均固定。对于图采用邻接矩阵进行存储。对于某个像素的邻居，为上下左右和对角线上至多8个节点，进而表示为图</p><h3 id="文本转化为图"><a href="#文本转化为图" class="headerlink" title="文本转化为图"></a>文本转化为图</h3><p>可以将每一个词表示为一个顶点，上一个词和下一个词之间有一个有向的边。</p><h3 id="其它问题转化为图"><a href="#其它问题转化为图" class="headerlink" title="其它问题转化为图"></a>其它问题转化为图</h3><h4 id="分子转化为图"><a href="#分子转化为图" class="headerlink" title="分子转化为图"></a>分子转化为图</h4><p>可以使每个原子表示一个节点，原子之间有边相连则表示一条边。</p><h4 id="社交网络图"><a href="#社交网络图" class="headerlink" title="社交网络图"></a>社交网络图</h4><p>如同一场景中出现过的人，可以将其对应的节点连一条边。</p><h4 id="引用图"><a href="#引用图" class="headerlink" title="引用图"></a>引用图</h4><p>如文章A引用文章B，则可以连接A指向B的有向边。</p><h3 id="图机器学习的任务"><a href="#图机器学习的任务" class="headerlink" title="图机器学习的任务"></a>图机器学习的任务</h3><ul><li>图层面的任务，如识别有几个环进而对图进行分类</li><li>顶点层面的任务，如对两个复杂的社交网络图，对其中以两个人为核心的两个不同阵营，判断每个人属于哪个阵营</li><li>边层面的任务，预测边的属性</li></ul><h3 id="机器学习用于图上的挑战"><a href="#机器学习用于图上的挑战" class="headerlink" title="机器学习用于图上的挑战"></a>机器学习用于图上的挑战</h3><p><em>（此处机器学习特指神经网络）</em></p><p>图上有四种信息：顶点的属性、边的属性、全局信息和连接性。前三种均可用向量表示，但连接性表示比较困难。</p><p>一种朴素想法是使用邻接矩阵，连接则用1表示，未连接用0表示。但是这种方法表示的矩阵会非常大。如果使用稀疏矩阵，在存储上可行，但要高效计算或者在GPU上计算较为困难。此外，由于交换任意行和任意列不会产生影响，这意味着交换任意行或任意列后的图放进神经网络，出来的结果应该与原先相同。</p><p>因此我们可以采用如下的形式。使用一个向量来表示节点，每个节点的属性使用一个标量来表示；用一个向量来表示边，每个边的属性也使用一个标量来表示；使用邻接链表来表示连接性。如下图所示：</p><p><img src="/img/GNN1.png" alt=""></p><h2 id="图神经网络"><a href="#图神经网络" class="headerlink" title="图神经网络"></a>图神经网络</h2><p>图神经网络是对图上所有的属性，包括顶点、边、上下文等，进行一个可以优化的变换，而这个变换可以保持住图的对称信息（顶点重新排序后结果不变）。此处采用信息传递的神经网络。图神经网络输入为图，输出也是图，对图的顶点、边和全局上下文进行变换，但不对连接性产生改变。</p><h3 id="最简单的GNN"><a href="#最简单的GNN" class="headerlink" title="最简单的GNN"></a>最简单的GNN</h3><p>使用上文所提出的数据结构，对全局上下问信息、顶点和边分别建立多层感知机，从而获得一个新的图。</p><h3 id="GNN-Predictions-by-Pooling-Information"><a href="#GNN-Predictions-by-Pooling-Information" class="headerlink" title="GNN Predictions by Pooling Information"></a>GNN Predictions by Pooling Information</h3><p>若没有顶点点向量，则使用汇聚/池化（Pooling）来得到节点向量。将与该节点的边的向量和全局向量一起相加得到新的向量（此处假设全局向量和边的向量维度相同，如果不同则需要进行投影），得到的新的向量作为节点的向量。最后进入全连接层得到顶点的输出。</p><p><img src="/img/GNN2.png" alt=""></p><p>同样的，如果只有顶点向量和全局向量，则将顶点向量和全局向量汇聚到边上，然后进入边向量的输出层，最后得到边的输出。</p><p>如果没有全局向量，则可以把所有的顶点向量加起来得到一个全局向量，并进入全局的输出层得到全局的输出。</p><p>因此最简单的GNN为如下的结构：给定输入的图，进入一系列的GNN层，每个层有三个MLP对应三种不同的属性。最后输出得到保持整个图结构的输出，但里面所有的属性发生了变化，而根据要对哪个属性做预测则添加合适的输出层，如果有信息缺失的话则加入合适的汇聚层即可。这样就可以完成一个简单的预测。</p><p><img src="/img/GNN3.png" alt=""></p><p>然而这种方式有所欠缺，因为将三种属性割裂开，并不能有效地融合和利用整个图的信息，顶点与边分开单独计算。因此需要一种其它方式。</p><h3 id="信息传递"><a href="#信息传递" class="headerlink" title="信息传递"></a>信息传递</h3><p>在顶点输入MLP时，不再只是单纯输入顶点向量，而是采用将顶点向量与此顶点连接的顶点的向量相加组成的向量输入MLP进行顶点的更新，即聚合步与更新步。当叠加很多层，可以实现顶点信息长距离的传递。</p><p>其中顶点周围距离为1的邻居成为1-近邻。上述步骤即$\rho_{V_n \rightarrow V_n}$</p><p><img src="/img/GNN4.png" alt=""></p><h3 id="Learning-edge-representation"><a href="#Learning-edge-representation" class="headerlink" title="Learning edge representation"></a>Learning edge representation</h3><p>对于如何将顶点的信息传递给边，将边的信息传递给顶点，有如下的方式：</p><ul><li><p>首先通过$\rho_{V_n \rightarrow E_n}$将顶点的向量传递给边，若维度不同则进行投影再传递或使用concat将两个向量并在一起。</p></li><li><p>然后再进行$\rho_{E_n \rightarrow V_n}$将边的信息再传递给顶点。</p></li></ul><p>也可以反过来：</p><ul><li><p>先做顶点的更新$\rho_{E_n \rightarrow V_n}$</p></li><li><p>再做边的更新$\rho_{V_n \rightarrow E_n}$</p></li></ul><p>以上两种方法会出现不同的结果，且没有孰优孰劣之分。此外还可以进行交替更新。</p><p><img src="/img/GNN5.png" alt=""></p><h3 id="Adding-global-representations"><a href="#Adding-global-representations" class="headerlink" title="Adding global representations"></a>Adding global representations</h3><p><em>全局信息的更新</em></p><p>可以增加一个虚拟的顶点，称为<strong>master node</strong>或<strong>context vector</strong>，这个顶点与所有的V和E里面的内容均相连。当把顶点的信息汇聚给边的时候，会把U的信息也汇聚过来；当汇聚顶点时，也会把U汇聚过来；当汇聚U的时候，会把顶点和边的信息一起汇聚到U上，再做更新。</p><p><img src="/img/GNN6.png" alt=""></p><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>GNN对超参数较为敏感，通常参数有四种：网络有多少层，每个属性的嵌入（embedding）维度有多高，汇聚（pooling）的操作是什么类型（最大值、均值等），怎么做信息传递（是否做信息传递，哪些属性之间做信息传递）。</p><h2 id="相关技术"><a href="#相关技术" class="headerlink" title="相关技术"></a>相关技术</h2><h3 id="采样（batching）"><a href="#采样（batching）" class="headerlink" title="采样（batching）"></a>采样（batching）</h3><p>如果对整个图进行计算，可能最终中间结果会非常大，因而要进行采样。常见的采样方法如下：</p><ol><li>随机采样一些点，将这些点点最近的邻居找出来，在计算时在这个子图上进行计算；</li><li>随机游走：随机在图上找一条边，沿着这条边走到下一个节点，沿着这个图随机走，规定最多随机走多少步，从而得到一个子图；</li><li>结合上面两种，随机走三步，然后把这三步中的每个邻居的节点全部找出来；</li><li>随机选一个点，找出第1近邻，2近邻…k近邻，即做宽度遍历得到子图。</li></ol><h3 id="Inductive-bias"><a href="#Inductive-bias" class="headerlink" title="Inductive bias"></a>Inductive bias</h3><p>此模型假设了在神经网络中保持了图的对称性。</p><h3 id="汇聚操作的比较"><a href="#汇聚操作的比较" class="headerlink" title="汇聚操作的比较"></a>汇聚操作的比较</h3><p>汇聚操作可以求和、求平均、求最大值，然而并没有哪种特别理想。</p><hr><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><a href="https://distill.pub/2021/gnn-intro/">Sanchez-Lengeling, et al., “A Gentle Introduction to Graph Neural Networks”, Distill, 2021.</a></li><li><a href="https://www.bilibili.com/video/BV1iT4y1d7zP">零基础多图详解图神经网络</a></li></ol>]]></content>
    
    
    <summary type="html">对图神经网络的简要介绍和入门</summary>
    
    
    
    <category term="AI" scheme="https://epsilonzyj.github.io/categories/AI/"/>
    
    <category term="Graph ML" scheme="https://epsilonzyj.github.io/categories/AI/Graph-ML/"/>
    
    <category term="GNN" scheme="https://epsilonzyj.github.io/categories/AI/Graph-ML/GNN/"/>
    
    
    <category term="AI" scheme="https://epsilonzyj.github.io/tags/AI/"/>
    
    <category term="Graph ML" scheme="https://epsilonzyj.github.io/tags/Graph-ML/"/>
    
    <category term="GNN" scheme="https://epsilonzyj.github.io/tags/GNN/"/>
    
  </entry>
  
  <entry>
    <title>软件与工具集 | Fancy Tools</title>
    <link href="https://epsilonzyj.github.io/posts/ebcd0e10.html"/>
    <id>https://epsilonzyj.github.io/posts/ebcd0e10.html</id>
    <published>2025-02-25T16:00:00.000Z</published>
    <updated>2025-07-27T15:11:59.218Z</updated>
    
    <content type="html"><![CDATA[<h2 id="跨平台工具"><a href="#跨平台工具" class="headerlink" title="跨平台工具"></a>跨平台工具</h2><h3 id="AI工具"><a href="#AI工具" class="headerlink" title="AI工具"></a>AI工具</h3><h4 id="API中转"><a href="#API中转" class="headerlink" title="API中转"></a>API中转</h4><ol><li><a href="https://cloud.siliconflow.cn/models">SiliconFlow</a>：国产厂商，优势在于没有汇率等影响而相对较便宜，缺点就是不含国外模型厂商的API，当需要使用Claude等在某些场景下表现更好的国外模型时有明显缺陷</li><li><a href="https://openrouter.ai">OpenRouter</a>：国外大模型API中转平台，可免费调用一些比较好的模型，但因为有汇率因素导致部分模型价格对学生等群体来说比较高</li></ol><h4 id="AI工具及模型"><a href="#AI工具及模型" class="headerlink" title="AI工具及模型"></a>AI工具及模型</h4><p><em>写在前面：如果是用于做研究或者是考虑深入某一领域等，国产大模型很多似乎都表现得比较拉垮，因此笔者也懒得去尝试一些模型。就身边的同学等使用体验来看，对于国产大模型，在下文中提到的相对比较高质量，其它的模型甚至BAT的似乎更多的是提供情绪价值，并没有多少辅助工作学习的实际作用。当然，考虑到国产大模型其实免费的偏多，并且可以不依赖镜像站等直接访问，相对来说还是有优势的。因此，如果要深入某一领域，还是需要自行寻找一下比较好的模型，从而达到事半功倍的效果。</em></p><ol><li><a href="https://iflow.cn">心流AI</a>：可用于查找论文，阅读论文（论文翻译）等</li><li><a href="https://ai-bot.cn">AI工具集</a>：比较全的AI工具集，查找一些想要的AI工具在这个平台上都能找到</li><li><a href="https://claude.ai/">Claude</a>：写代码全靠Claude捞😋</li><li><a href="https://chatgpt.com">ChatGPT</a>：通用模型，特殊领域表现并不如其它模型</li><li><a href="https://chat.deepseek.com">DeepSeek</a>：数学推理等比较强，可以作为通用模型，文本处理比较厉害，多模态（如图片识别之类的任务）能力较弱，写代码能力还可以。当然，建议使用深度求索公司直接提供的模型，其它厂商自己训练的模型由于数据集等问题，训练效果良莠不齐。</li><li><a href="https://www.kimi.com">Kimi AI</a>：能力还算可以，可以用于当作通用模型，可用于搜索一些内容，多模态能力比较强</li><li><a href="https://manus.im/app">Manus</a>：校友产品支持一波～～可以进行一些复杂任务</li></ol><h4 id="AI杂项-前端"><a href="#AI杂项-前端" class="headerlink" title="AI杂项/前端"></a>AI杂项/前端</h4><ol><li><a href="https://github.com/CherryHQ/cherry-studio?tab=readme-ov-file">Cherry Studio</a>：可以集成多种大语言模型的客户端</li></ol><h3 id="计算机学术工具"><a href="#计算机学术工具" class="headerlink" title="计算机学术工具"></a>计算机学术工具</h3><ol><li><a href="https://arxiv.org">arXiv</a>：未发表或已发表的文章均有，可以查找最新的科研进展</li><li><a href="https://dblp.org">dblp</a>：CS论文</li><li><a href="https://scholar.google.com">Google Scholar</a>：各种论文</li><li><a href="https://paperswithcode.com">Paper with code</a>：主要是关于机器学习和数据科学的论文和开源代码</li><li><a href="https://snip.mathpix.com/home">Mathpix</a></li><li><a href="https://simpletex.cn/ai/latex_ocr">Simpleletex</a>：Mathpix的平替</li><li><a href="https://app.diagrams.net">Draw IO</a>：在线绘图工具（流程图等），<a href="https://github.com/jgraph/drawio-desktop/tree/v26.2.15">客户端</a></li><li><a href="https://typora.io">Typora</a>：Markdown编辑器</li></ol><h3 id="服务器等"><a href="#服务器等" class="headerlink" title="服务器等"></a>服务器等</h3><ol><li><a href="https://www.autodl.com/home">AutoDL</a>：深度学习租卡网站</li></ol><h3 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h3><ol><li><a href="https://github.com/Eugeny/tabby">Tabby终端</a>：开源免费的终端</li></ol><h3 id="IDE-编辑器"><a href="#IDE-编辑器" class="headerlink" title="IDE/编辑器"></a>IDE/编辑器</h3><ol><li><a href="https://code.visualstudio.com">VS Code</a></li><li><a href="https://www.jetbrains.com/zh-cn/">Jetbrains全家桶</a></li><li><a href="https://www.cursor.com">Cursor</a>：AI编辑器</li></ol><h2 id="Mac-OS"><a href="#Mac-OS" class="headerlink" title="Mac OS"></a>Mac OS</h2><h3 id="必推"><a href="#必推" class="headerlink" title="必推"></a>必推</h3><ol><li><a href="https://github.com/Homebrew/brew/releases">HomeBrew</a>：MacOS上（或许）最好的软件包管理器</li><li><a href="https://github.com/iina/iina/tree/v1.4.0-beta1">IINA播放器</a>：MacOS上较好的播放器</li><li><a href="https://pilotmoon.com/scrollreverser/">Scroll Reverser</a>：MacOS上鼠标滚轮反向，不使用鼠标则无需使用，<a href="https://github.com/pilotmoon/Scroll-Reverser">源码</a></li></ol><h3 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h3><ol><li><a href="https://developer.apple.com/xcode/">XCode</a>：MacOS上的开发工具，iOS开发必备</li><li><a href="https://github.com/nicklockwood/SwiftFormat">SwiftFormat for Xcode</a>：Swift代码格式化工具</li><li><a href="https://apps.apple.com/us/app/devcleaner-for-xcode/id1388020431">DevCleaner</a>：MacOS上的垃圾清理工具</li><li><a href="https://github.com/github/copilot-extension">Github Copilot for Xcode</a>：Xcode上的Github Copilot插件，虽然不是很好用，但是能用就行</li></ol><h3 id="系统工具-杂项"><a href="#系统工具-杂项" class="headerlink" title="系统工具/杂项"></a>系统工具/杂项</h3><p>得益于Mac强大的社区，我们总是可以找到一些很有意思的工具或者是插件。此部分很多东西都来源于Github，在此也需要感谢每一位无私用心付出的开源社区作者。</p><ol><li><a href="https://www.parallels.cn/products/desktop/">Parallels Desktop</a>：MacOS上的虚拟机，可以运行Windows，还有很多附加的工具，虽然不是很好用，但是也还算可以</li><li><a href="https://apps.apple.com/us/app/hidden-bar/id1452453066">Hidden Bar</a>：MacOS上隐藏菜单栏的工具</li><li><a href="https://cleanmymac.com">CleanMyMac</a>：MacOS上的垃圾清理工具，很贵但很好用</li><li><a href="https://www.macbartender.com">Bartender</a>：和Hidden Bar类似，但是功能更加强大，可以隐藏菜单栏，Dock栏，Finder栏等，但是很贵</li><li><a href="https://theunarchiver.com">The Unarchiver</a>：MacOS自带解压，但对于一些除了zip之外其它的压缩包格式并不支持，而这个软件支持几乎所有压缩包格式的解压，而且免费</li><li><a href="https://theboring.name">boringNotch</a>：没什么比较大的实际用处，只是将MacBook上的摄像头的一部分变为和iPhone一样的灵动岛，装饰使用</li><li><a href="https://icemenubar.app">IceMenubar</a>：和Hidden Bar类似，开源，免费，功能强大，比较好用</li><li><a href="https://apps.apple.com/cn/app/amphetamine/id937984704?mt=12">Amphetamine</a>：用于设置防止系统睡眠，适合开发、编译、进行深度学习等需要不熄屏的场景，并且可以个性化设置，无需将整个系统设置为不熄屏</li><li><a href="https://www.keka.io/en/">Keka</a>：Mac上最强大的压缩软件之一，可以去除Mac自带的系统文件。在官网上可以免费下载，但有条件可以在App Store上购买支持良心作者。</li><li><a href="https://apps.apple.com/us/app/pixelstyle-photo-editor/id1244649277?mt=12">PixelStyle</a>：Mac上比较好的图片编辑软件，相比Adobe Photoshop等的优势就是免费</li></ol><h2 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h2><p><del>Windows没有必要推荐工具。</del>笔者太懒了，以后再来写吧。如果一定要推荐，那就推荐WSL吧。</p><ol><li><a href="https://learn.microsoft.com/en-us/windows/wsl/install">WSL文档</a>：<del>不知道放什么，就放个文档链接吧。</del>既想用Linux又想用Windows的用户的福音，同时共享同一个文件系统，当然还可以直接用来做深度学习。</li></ol>]]></content>
    
    
    <summary type="html">一些实用工具集与开发工具</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Java环境配置</title>
    <link href="https://epsilonzyj.github.io/posts/f7539049.html"/>
    <id>https://epsilonzyj.github.io/posts/f7539049.html</id>
    <published>2025-02-25T16:00:00.000Z</published>
    <updated>2025-07-27T15:11:59.218Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MacOS"><a href="#MacOS" class="headerlink" title="MacOS"></a>MacOS</h2><h3 id="使用Homebrew安装JDK"><a href="#使用Homebrew安装JDK" class="headerlink" title="使用Homebrew安装JDK"></a>使用Homebrew安装JDK</h3><ul><li>配置Homebrew</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)&quot;</span><br></pre></td></tr></table></figure><h4 id="安装OpenJDK"><a href="#安装OpenJDK" class="headerlink" title="安装OpenJDK"></a>安装OpenJDK</h4><p>查询jdk版本信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew search jdk</span><br></pre></td></tr></table></figure><p>安装特定版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install openjdk@17</span><br></pre></td></tr></table></figure><h4 id="配置JDK"><a href="#配置JDK" class="headerlink" title="配置JDK"></a>配置JDK</h4><p>注意，运行完以上命令后，终端会出现如下的信息：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">For the system Java wrappers to find this JDK, symlink it with</span><br><span class="line">  sudo ln -sfn /opt/homebrew/opt/openjdk@17/libexec/openjdk.jdk /Library/Java/JavaVirtualMachines/openjdk-17.jdk</span><br><span class="line"></span><br><span class="line">openjdk@17 is keg-only, which means it was not symlinked into /opt/homebrew,</span><br><span class="line">because this is an alternate version of another formula.</span><br><span class="line"></span><br><span class="line">If you need to have openjdk@17 first in your PATH, run:</span><br><span class="line">  echo &#x27;export PATH=&quot;/opt/homebrew/opt/openjdk@17/bin:$PATH&quot;&#x27; &gt;&gt; ~/.zshrc</span><br><span class="line"></span><br><span class="line">For compilers to find openjdk@17 you may need to set:</span><br><span class="line">  export CPPFLAGS=&quot;-I/opt/homebrew/opt/openjdk@17/include&quot;</span><br><span class="line">==&gt; Summary</span><br><span class="line">🍺  /opt/homebrew/Cellar/openjdk@17/17.0.14: 636 files, 304.3MB</span><br><span class="line">==&gt; Running `brew cleanup openjdk@17`...</span><br><span class="line">Disable this behaviour by setting HOMEBREW_NO_INSTALL_CLEANUP.</span><br><span class="line">Hide these hints with HOMEBREW_NO_ENV_HINTS (see `man brew`).</span><br></pre></td></tr></table></figure><p>根据指示，运行相应的命令。首先运行如下命令使得系统可以找到当前下载的JDK：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ln -sfn /opt/homebrew/opt/openjdk@17/libexec/openjdk.jdk /Library/Java/JavaVirtualMachines/openjdk-17.jdk</span><br></pre></td></tr></table></figure><p>可以通过tree命令来检查是否成功。</p><ul><li>若没有安装过tree，则运行以下命令：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install tree</span><br></pre></td></tr></table></figure><p>检查是否成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tree /Library/Java</span><br></pre></td></tr></table></figure><h4 id="检查当前JDK以及Java环境"><a href="#检查当前JDK以及Java环境" class="headerlink" title="检查当前JDK以及Java环境"></a>检查当前JDK以及Java环境</h4><p>执行以下命令可以查看当前系统使用的JDK版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/libexec/java_home</span><br></pre></td></tr></table></figure><p>执行以下命令可查看当前系统使用的Java版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java --version</span><br></pre></td></tr></table></figure><h4 id="多版本JDK管理"><a href="#多版本JDK管理" class="headerlink" title="多版本JDK管理"></a>多版本JDK管理</h4><p>先要查找到JDK的地址，采用如下的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/libexec/java_home -V</span><br></pre></td></tr></table></figure><p>若没有建过.bash_profile文件，则在根目录下建此配置文件，并打开此配置文件。如已经有，则添加即可。其中地址均使用上面命令查找出来的地址。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#配置JDK路径</span><br><span class="line">export JAVA_11_HOME=/Library/Java/JavaVirtualMachines/jdk-11.jdk/Contents/Home</span><br><span class="line">export JAVA_17_HOME=/Library/Java/JavaVirtualMachines/jdk-17.jdk/Contents/Home</span><br><span class="line"> </span><br><span class="line"># 设置默认JDK版本，默认使用 JDK17</span><br><span class="line">export JAVA_HOME=$JAVA_17_HOME</span><br><span class="line">CLASSPATH=$JAVA_HOME/lib/tools.jar:$JAVA_HOME/lib/dt.jar:.</span><br><span class="line"> </span><br><span class="line"># 配置alias命令动态切换JDK版本  </span><br><span class="line">alias jdk11=&quot;export JAVA_HOME=$JAVA_11_HOME&quot;</span><br><span class="line">alias jdk17=&quot;export JAVA_HOME=$JAVA_17_HOME&quot;</span><br><span class="line"> </span><br><span class="line">export JAVA_HOME</span><br><span class="line">export CLASSPATH</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>若嫌麻烦可以跳过查看地址那一步，直接在上述.bash_profile中编辑：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=$(/usr/libexec/java_home -v11)</span><br><span class="line">export JAVA_8_HOME=$(/usr/libexec/java_home -v1.8)</span><br><span class="line">export JAVA_11_HOME=$(/usr/libexec/java_home -v11)</span><br><span class="line"></span><br><span class="line">alias java8=&#x27;export JAVA_HOME=$JAVA_8_HOME&#x27;</span><br><span class="line">alias java11=&#x27;export JAVA_HOME=$JAVA_11_HOME&#x27;</span><br></pre></td></tr></table></figure><p>保存配置文件，在终端中输出如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source .bash_profile</span><br></pre></td></tr></table></figure><p>可以通过如下命令查看是否配置成功：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $JAVA_HOME</span><br></pre></td></tr></table></figure><h4 id="JDK版本切换"><a href="#JDK版本切换" class="headerlink" title="JDK版本切换"></a>JDK版本切换</h4><p>在终端中输入命令：jdk/java版本号 即可，如</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jdk17</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java17</span><br></pre></td></tr></table></figure><p>注意看清楚编辑时alias后面的命令到底是jdk还是java</p><h2 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h2><h3 id="下载并安装JDK"><a href="#下载并安装JDK" class="headerlink" title="下载并安装JDK"></a>下载并安装JDK</h3><p>上<a href="https://www.oracle.com/java/technologies/downloads/?er=221886">官网</a>下载所需的JDK，运行相应的安装程序即可完成安装。若从未注册过账号，需要在官网注册账号后才能下载。</p><h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><p>将以上的JDK目录，在系统变量中，配置为<strong>JAVA_HOME</strong>，路径为JDK路径，如：C:\Program Files\Java\jdk1.8.0_191。</p><p>然后，在Path中添加两个路径，分别为</p><ul><li><p><strong>%JAVA_HOME%\bin</strong></p></li><li><p><strong>%JAVA_HOME%\jre\bin</strong></p></li></ul><p>此外，还需要配置<strong>CLASSPATH</strong>变量。若本来存在这个变量，则进行编辑，若无则新建。变量值为</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;</span><br></pre></td></tr></table></figure><p>可以通过以下命令来检查是否安装成功：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java</span><br></pre></td></tr></table></figure><h2 id="Java运行"><a href="#Java运行" class="headerlink" title="Java运行"></a>Java运行</h2><p>最方便和最简单的当然是直接拿IDEA一键运行啦，当然稍微麻烦点的就是配置VSCode。但如果除去这两个，就需要依靠运行脚本来运行Java程序了。</p><p>下面将展示脚本编写示例。</p><h3 id="Windows脚本"><a href="#Windows脚本" class="headerlink" title="Windows脚本"></a>Windows脚本</h3><p>在当前工程目录下，创建run.bat脚本文件（文件名是什么随便起就行，不一定要为run.bat）。假设我们的工程目录是如下的情况，我们可以在脚本文件中对应编辑如下内容：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">JavaDemo</span><br><span class="line">├── .idea</span><br><span class="line">├── bin</span><br><span class="line">│   └── production</span><br><span class="line">│       └── JavaDemo</span><br><span class="line">│           └── hust</span><br><span class="line">│               └── cs</span><br><span class="line">│                   └── javacourse</span><br><span class="line">│                       └── ch1</span><br><span class="line">│                           └── HelloWorld.class</span><br><span class="line">├── src</span><br><span class="line">│   └── hust.cs.javacourse.ch1</span><br><span class="line">│       └── HelloWorld.java</span><br><span class="line">└── JavaDemo.iml</span><br></pre></td></tr></table></figure><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> JAVA_HOME=D:\jdk1.<span class="number">8</span>.<span class="number">0</span>_231_64bit</span><br><span class="line"><span class="built_in">set</span> PROJECT_HOME=D:\IdeaWorkspace\JavaDemo</span><br><span class="line"><span class="built_in">set</span> <span class="built_in">path</span>=<span class="variable">%path%</span>;<span class="variable">%JAVA_HOME%</span>\bin</span><br><span class="line"><span class="built_in">set</span> classpath=<span class="variable">%classpath%</span>;<span class="variable">%PROJECT_HOME%</span>\bin\production\JavaDemo</span><br><span class="line"></span><br><span class="line">java -classpath <span class="variable">%classpath%</span> hust.cs.javacourse.ch1.HelloWorld</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li><p>JAVA_HOME设置JAVA_HOME环境变量</p></li><li><p>PROJECT_HOME设置PROJECT_HOME环境变量</p></li><li><p>path设置把JAVA_HOME目录的子目录bin加到环境变量PATH</p></li><li><p>classpath把PROJECT_HOME目录的子目录bin\production\JavaDemo加到环境变量CLASSPATH，这个目录是类HelloWorld所属包的顶级目录</p></li><li><p>最后一行为运行指令，启动类时，用类的完全限定名（带包名限定），并且带-classspath选项</p></li></ul><p>运行时直接命令行输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./run.bat</span><br></pre></td></tr></table></figure><hr><p>参考资料：</p><ol><li><p><a href="https://blog.csdn.net/Jarvs/article/details/134669580">Mac JDK环境变量配置 及 JDK多版本切换</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/298535991">新 Mac 如何优雅地配置 Java 开发环境</a></p></li></ol>]]></content>
    
    
    <summary type="html">Java环境配置方法（兼MacOS和Windows）</summary>
    
    
    
    <category term="环境配置" scheme="https://epsilonzyj.github.io/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
    
    <category term="Java" scheme="https://epsilonzyj.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Hello Hexo</title>
    <link href="https://epsilonzyj.github.io/posts/4a17b156.html"/>
    <id>https://epsilonzyj.github.io/posts/4a17b156.html</id>
    <published>2025-02-22T16:00:00.000Z</published>
    <updated>2025-07-27T15:11:59.218Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><h2 id="More"><a href="#More" class="headerlink" title="More"></a>More</h2><p>可以参考安知鱼的<a href="https://blog.anheyu.com/posts/sdxhu.html#配置自定义-css">博客</a>和<a href="https://www.bilibili.com/video/BV1CG41157fr?spm_id_from=333.788.player.switch&amp;vd_source=2e36fae16810615c2d859efc03aef1c4">Bilibili</a></p>]]></content>
    
    
    <summary type="html">Hexo+Butterfly框架参考文档</summary>
    
    
    
    <category term="本站搭建" scheme="https://epsilonzyj.github.io/categories/%E6%9C%AC%E7%AB%99%E6%90%AD%E5%BB%BA/"/>
    
    
  </entry>
  
</feed>
